# 複数パッケージ対応プロトタイプ（moon.pkg 時代）

このドキュメントは、実装で確認しながら「自身で定義した複数パッケージ」を扱えるかを調査した結果です。

## 結論

- `buildPackage` をパッケージごとに順番に呼び出し、依存パッケージの `mi` を `miFiles` に渡すことで、**ユーザー定義パッケージ同士の import は動作**しました。
- 最後に `linkCore` へ `coreFiles`（標準 core + 各パッケージ core）をまとめて渡すことで実行可能な JS が生成できます。
- `moon.pkg` / `moon.pkg.json` を入力テキストとして直接混ぜる方式は `mbt` として解釈されるため、この環境では使えませんでした（`buildPackage` の入力が `mbtFiles` のため）。

## このリポジトリでの入力方法（プロトタイプ）

既存の複数ファイル記法を踏襲し、`-- filename --` の `filename` にパッケージ名プレフィックスを含めます。

```moonbit
-- main/main.mbt --
fn main {
  println(@dep.add(3, 4))
}
-- dep/lib.mbt --
pub fn add(a : Int, b : Int) -> Int {
  a + b
}
```

- `main/` と `dep/` がパッケージ名として扱われます。
- 依存解決は `@dep.xxx` の参照から判定し、`dep` を先にコンパイルします。

## 実装上の制限

- まだ **Run（実行）向けのプロトタイプ実装**です。
- **Test ボタン経由の複数パッケージは未対応**です（エラーを返す）。
- import 依存の検出は簡易実装（`@pkg.` パターン）です。
- ユーザー定義パッケージのみ対象で、外部依存の一般解決機構は持ちません。

## moon.pkg について

- issue コメントの通り、MoonBit v0.8 では `moon.pkg` が新形式です。
- ただし現状の `moonc-worker` 経由 API では、入力として扱えるのは `mbtFiles` が中心で、`moon.pkg` をそのまま渡して解決する方式はこの実装では確認できませんでした。
- そのため本プロトタイプでは、`moon.pkg` 自体のパースではなく、**オンライン入力内のファイル名規約（`pkg/file.mbt`）でパッケージ境界を表現**しています。
