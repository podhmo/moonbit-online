# 複数パッケージ対応プロトタイプ（moon.pkg 時代）

このドキュメントは、実装で確認しながら「自身で定義した複数パッケージ」を扱えるかを調査した結果です。

## 結論

- `buildPackage` をパッケージごとに順番に呼び出し、依存パッケージの `mi` を `miFiles` に渡すことで、**ユーザー定義パッケージ同士の import は動作**しました。
- 最後に `linkCore` へ `coreFiles`（標準 core + 各パッケージ core）をまとめて渡すことで実行可能な JS が生成できます。
- `moon.pkg` / `moon.pkg.json` を入力テキストとして直接混ぜる方式は `mbt` として解釈されるため、この環境では使えませんでした（`buildPackage` の入力が `mbtFiles` のため）。
- **ネスト依存（例: `main -> a -> b`）は Run 経路では可能**でした（実装とテストで確認）。

## このリポジトリでの入力方法（プロトタイプ）

既存の複数ファイル記法を踏襲し、`-- filename --` の `filename` にパッケージ名プレフィックスを含めます。

```moonbit
-- main/main.mbt --
fn main {
  println(@dep.add(3, 4))
}
-- dep/lib.mbt --
pub fn add(a : Int, b : Int) -> Int {
  a + b
}
```

- `main/` と `dep/` がパッケージ名として扱われます。
- ファイル名は **`pkg/file.mbt`（1階層）限定**です。`pkg/dir/file.mbt` は非対応です。
- 依存解決は `@dep.xxx` の参照から判定し、`dep` を先にコンパイルします。

## 実装上の制限

- まだ **Run（実行）向けのプロトタイプ実装**です。
- **Test ボタン経由の複数パッケージは未対応**です（エラーを返す）。
- import 依存の検出は簡易実装（`@pkg.` パターン）です。
- ユーザー定義パッケージのみ対象で、外部依存の一般解決機構は持ちません。

### 制限の詳細（今回の調査で確認したもの）

- ✅ `main -> a -> b` のような**多段依存（非循環）は動作**。
  - 依存順に `buildPackage` して `miFiles` をつなぐ方式で成立。
- ❌ **ネストしたディレクトリは未対応**。入力は **単一階層のみ**（`pkg/file.mbt`）。
  - `pkg/dir/file.mbt` のようなパスはエラーにする。
- ❌ **循環依存**（`a -> b -> a`）は実装側で検出してエラーにしている。
- ⚠️ 依存検出は `@pkg.` のテキスト走査なので、厳密パーサベースではない。
  - そのためコメントや文字列中の `@pkg.` による誤検出の可能性は残る。
- ❌ **Test ボタンでの複数パッケージ未対応**。
  - `compileTest` は現状 `genTestInfo` と単一パッケージ前提のドライバ生成に寄せているため、複数パッケージ入力を明示的に拒否している。
  - そのため、複数パッケージでは Run は可能でも Test は不可（現時点の仕様）。

## moon.pkg について

- issue コメントの通り、MoonBit v0.8 では `moon.pkg` が新形式です。
- ただし現状の `moonc-worker` 経由 API では、入力として扱えるのは `mbtFiles` が中心で、`moon.pkg` をそのまま渡して解決する方式はこの実装では確認できませんでした。
- そのため本プロトタイプでは、`moon.pkg` 自体のパースではなく、**オンライン入力内のファイル名規約（`pkg/file.mbt`）でパッケージ境界を表現**しています。
